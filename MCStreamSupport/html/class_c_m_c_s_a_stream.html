<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>MC_Stream DLL: Main Page</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="mcsdox.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>CMCSAStream Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="CMCSAStream" -->
<p>Retrieve MC_Rack data stream.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;MCSAStream.h&gt;</code></p>

<p><a href="class_c_m_c_s_a_stream-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_c_s_a_stream.html#a1ab256e2dac0b01af69cf189626685a8">CMCSAStream</a> (<a class="el" href="class_c_m_c_s_a_stream_file.html">CMCSAStreamFile</a> *pStreamFile)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stream constructor.  <a href="#a1ab256e2dac0b01af69cf189626685a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_c_s_a_stream.html#a5b1e82dbe9560579310d584b045e5a15">GetBufferID</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the ID of the stream.  <a href="#a5b1e82dbe9560579310d584b045e5a15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_c_s_a_stream.html#a4e06866a2f45b4df9fc5f13b6657fc47">GetChannelCount</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get stream channel count.  <a href="#a4e06866a2f45b4df9fc5f13b6657fc47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_c_s_a_stream.html#aa2e42b0b232ed753c8dafccfa5a33dc7">GetHeaderVersion</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get stream header version.  <a href="#aa2e42b0b232ed753c8dafccfa5a33dc7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_c_s_a_stream.html#a92e6644b54f3566a049af6fb5c47f5a3">GetDataType</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get data type.  <a href="#a92e6644b54f3566a049af6fb5c47f5a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_c_s_a_stream.html#aed6661d2f2b5ffeff41f24031c542639">GetName</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get data stream name.  <a href="#aed6661d2f2b5ffeff41f24031c542639"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36c16e6adcb3fc51c31057a879bc3c3a"></a><!-- doxytag: member="CMCSAStream::GetComment" ref="a36c16e6adcb3fc51c31057a879bc3c3a" args="()" -->
virtual char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_c_s_a_stream.html#a36c16e6adcb3fc51c31057a879bc3c3a">GetComment</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Method is deprecated. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a720766f980a802c32bf6c6f3fa49d537"></a><!-- doxytag: member="CMCSAStream::GetID" ref="a720766f980a802c32bf6c6f3fa49d537" args="()" -->
virtual short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_c_s_a_stream.html#a720766f980a802c32bf6c6f3fa49d537">GetID</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Method is deprecated. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_c_s_a_stream.html#a7d0d83d67d41ab90c7dd9666626e4b8a">GetMilliSamplesPerSecond</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get milli samples per second.  <a href="#a7d0d83d67d41ab90c7dd9666626e4b8a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_c_s_a_stream.html#a2c09efef329e2795e536c956d4e2c5f5">GetSampleRate</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get sample rate in Hz.  <a href="#a2c09efef329e2795e536c956d4e2c5f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_c_s_a_stream.html#a679fd670f9b7e6bf4aee17c6620c5b0e">GetFormatVersion</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get format version.  <a href="#a679fd670f9b7e6bf4aee17c6620c5b0e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_c_s_a_stream.html#a8963396e7b65de404b09b7480eb1ce2c">GetUnitSign</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get unit sign.  <a href="#a8963396e7b65de404b09b7480eb1ce2c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_c_s_a_stream.html#a2fd3da3ee812839b662414e0225ebb31">GetADBits</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get number of AD bits.  <a href="#a2fd3da3ee812839b662414e0225ebb31"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual WORD&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_c_s_a_stream.html#add0777a46fc354dc7bf80fafbf090c63">GetADZero</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the AD zero value.  <a href="#add0777a46fc354dc7bf80fafbf090c63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_c_s_a_stream.html#a2d2323c977c875baf50f4dabd544cdb7">GetUnitsPerAD</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get units per AD step.  <a href="#a2d2323c977c875baf50f4dabd544cdb7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae55c099af69d9ff580290022794746dd"></a><!-- doxytag: member="CMCSAStream::GetBytesPerChannel" ref="ae55c099af69d9ff580290022794746dd" args="()" -->
virtual short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_c_s_a_stream.html#ae55c099af69d9ff580290022794746dd">GetBytesPerChannel</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Method is deprecated. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_c_s_a_stream.html#ae63923e76c26a4f3d80b70da81736ded">GetDefaultSamplesPerSegment</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of samples of a data segment.  <a href="#ae63923e76c26a4f3d80b70da81736ded"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_c_s_a_stream.html#a64ac39d0816a3bac583b67961b72c563">GetDefaultSegmentCount</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of data segments.  <a href="#a64ac39d0816a3bac583b67961b72c563"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_c_m_c_s_a_channel.html">CMCSAChannel</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_c_s_a_stream.html#a35f187575116d2d91117c02a6f954737">GetChannel</a> (short Index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the channel object.  <a href="#a35f187575116d2d91117c02a6f954737"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_c_s_a_stream.html#acb78c11c727e9b935361779ba15b1041">GetChannelName</a> (short Index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get name of the channel.  <a href="#acb78c11c727e9b935361779ba15b1041"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_c_s_a_stream.html#a5ef6e8abb21099311db3e4ea93f33c4b">GetInfo</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get Info object of the stream.  <a href="#a5ef6e8abb21099311db3e4ea93f33c4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_c_s_a_stream.html#a52fca28b0eb49e718d83bcfed697ef8d">HasContinuousData</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Has data stream continuous data.  <a href="#a52fca28b0eb49e718d83bcfed697ef8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_c_s_a_stream.html#a478aebe07348a029debfea838bbdea6a">HasRawData</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Has data stream raw data.  <a href="#a478aebe07348a029debfea838bbdea6a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_c_s_a_stream.html#a8ef0cc6315fb182e2bdad9454387a88b">GetRawData</a> (short *pData, long DataSize, <a class="el" href="class_c_m_c_s_a_time_stamp.html">CMCSATimeStamp</a> *tsFrom, <a class="el" href="class_c_m_c_s_a_time_stamp.html">CMCSATimeStamp</a> *tsTo)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get raw data.  <a href="#a8ef0cc6315fb182e2bdad9454387a88b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_c_s_a_stream.html#af408ce74713960b065fe558f92ca9294">GetRawDataOfChannel</a> (short *pData, long lIndex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get raw data of a single channel.  <a href="#af408ce74713960b065fe558f92ca9294"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_c_s_a_stream.html#ac1f2da251f43b536181fd300b9ce6061">GetRawDataOfChannelStartCount</a> (short *pData, long lIndex, long lStart, long lCount)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get raw data of a single channel.  <a href="#ac1f2da251f43b536181fd300b9ce6061"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_c_s_a_stream.html#adf45469b4fefdf17eb745421384afc78">GetRawDataBufferSize</a> (<a class="el" href="class_c_m_c_s_a_time_stamp.html">CMCSATimeStamp</a> *tsFrom, <a class="el" href="class_c_m_c_s_a_time_stamp.html">CMCSATimeStamp</a> *tsTo)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get buffer size.  <a href="#adf45469b4fefdf17eb745421384afc78"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_c_s_a_stream.html#a2655f49081adfd399e5614b29babffda">GetRawDataBufferSizeOfChannel</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get buffer size needed for a single channel.  <a href="#a2655f49081adfd399e5614b29babffda"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_c_s_a_stream.html#a0e062ed292a5af93b861edb670e5aae8">GetSweepRawDataBufferSize</a> (long lSweepIndex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get buffer size neede for a sweep.  <a href="#a0e062ed292a5af93b861edb670e5aae8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_c_s_a_stream.html#a2a895dd2e28561cdfab84262946e4fb6">GetSweepRawData</a> (short *pData, long DataSize, long lSweepIndex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get sweep data.  <a href="#a2a895dd2e28561cdfab84262946e4fb6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_c_s_a_stream.html#a2ddd2a90c00efeef133e7d86f82907f5">GetSweepRawDataOfChannel</a> (short *pData, long sweepsize, long lSweepIndex, long lIndex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get sweep data of a single channel.  <a href="#a2ddd2a90c00efeef133e7d86f82907f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual CMCSAChunk *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_c_s_a_stream.html#ae3c62748efff5b2c92e70b069af88eca">GetFirstChunk</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get first data chunk.  <a href="#ae3c62748efff5b2c92e70b069af88eca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual CMCSAChunk *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_c_s_a_stream.html#a50dfa6dd49f476938b95c2a227bf0c85">GetNextChunk</a> (CMCSAChunk *pCurrentChunk)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get next chunk object.  <a href="#a50dfa6dd49f476938b95c2a227bf0c85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual CMCSAChunk *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_c_s_a_stream.html#a107b166825e5199391e29a243eaf5114">GetChunkNextTo</a> (<a class="el" href="class_c_m_c_s_a_time_stamp.html">CMCSATimeStamp</a> *ts)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get chunk object which is next to a time stamp.  <a href="#a107b166825e5199391e29a243eaf5114"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_c_m_c_s_a_event.html">CMCSAEvent</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_c_s_a_stream.html#af040546102ff1684bac6a422cea3f35b">GetFirstEvent</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get first event of data stream.  <a href="#af040546102ff1684bac6a422cea3f35b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_c_m_c_s_a_event.html">CMCSAEvent</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_c_s_a_stream.html#aa37b1d647d254f0c748df28860a35230">GetNextEvent</a> (<a class="el" href="class_c_m_c_s_a_event.html">CMCSAEvent</a> *pCurrentEvent)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move to next Event.  <a href="#aa37b1d647d254f0c748df28860a35230"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_c_m_c_s_a_event.html">CMCSAEvent</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_c_s_a_stream.html#a741dc87881ed373730411715d74f2611">GetEventNextTo</a> (<a class="el" href="class_c_m_c_s_a_time_stamp.html">CMCSATimeStamp</a> *ts)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move to Event next ot the stime stamp.  <a href="#a741dc87881ed373730411715d74f2611"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_c_s_a_stream.html#a454e233e1d860b226431b0f9de3adf94">EventCountFromTo</a> (<a class="el" href="class_c_m_c_s_a_time_stamp.html">CMCSATimeStamp</a> *dispFrom, <a class="el" href="class_c_m_c_s_a_time_stamp.html">CMCSATimeStamp</a> *dispTo, long *arrEventCount)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get count of events within time stamp From to To.  <a href="#a454e233e1d860b226431b0f9de3adf94"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_c_s_a_stream.html#ac4f2b9b7ca3ee10c461b6c32a0b4021a">GetRelativeChannelPosX</a> (short Index) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get x channel position in a range from 0 (left) to 100 (right).  <a href="#ac4f2b9b7ca3ee10c461b6c32a0b4021a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_m_c_s_a_stream.html#a8f7b177b30fa7d1d0c80a918e0576a58">GetRelativeChannelPosY</a> (short Index) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get y channel position in a range from 0 (top) to 100 (bottom).  <a href="#a8f7b177b30fa7d1d0c80a918e0576a58"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Retrieve MC_Rack data stream. </p>
<p>A stream represents all data belonging to a source, for example the MC_Card, which provides raw data streams, or the spike sorter, which provides a spike stream. Each stream consists of 1 to serveral channels (maximum is 128 channels). Streams are managed by the MCStreamFile object. Please consult the code in the example project MC_StreamTest to learn how to create a stream object, access its channel and select a stream type for the extraction of data. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a1ab256e2dac0b01af69cf189626685a8"></a><!-- doxytag: member="CMCSAStream::CMCSAStream" ref="a1ab256e2dac0b01af69cf189626685a8" args="(CMCSAStreamFile *pStreamFile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CMCSAStream::CMCSAStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_m_c_s_a_stream_file.html">CMCSAStreamFile</a> *&nbsp;</td>
          <td class="paramname"> <em>pStreamFile</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stream constructor. </p>
<p>you usually don't need to call this directly. Use <a class="el" href="class_c_m_c_s_a_stream_file.html#a7786f418be1fb42dc605256fb69acc52" title="Get a pointer to a stream object.">CMCSAStreamFile::GetStream()</a> </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a454e233e1d860b226431b0f9de3adf94"></a><!-- doxytag: member="CMCSAStream::EventCountFromTo" ref="a454e233e1d860b226431b0f9de3adf94" args="(CMCSATimeStamp *dispFrom, CMCSATimeStamp *dispTo, long *arrEventCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CMCSAStream::EventCountFromTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_m_c_s_a_time_stamp.html">CMCSATimeStamp</a> *&nbsp;</td>
          <td class="paramname"> <em>dispFrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_m_c_s_a_time_stamp.html">CMCSATimeStamp</a> *&nbsp;</td>
          <td class="paramname"> <em>dispTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&nbsp;</td>
          <td class="paramname"> <em>arrEventCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get count of events within time stamp From to To. </p>
<p><a class="el" href="class_c_m_c_s_a_stream.html#a454e233e1d860b226431b0f9de3adf94" title="Get count of events within time stamp From to To.">EventCountFromTo()</a> returns the number of events per channel within the interval difined by time stamps From to To. The counts are written to the arrEventCount, which has to be of size 128 (because the maximum number of channels is 128). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dispFrom</em>&nbsp;</td><td>pointer to a time stamp representing the interval start time </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dispTo</em>&nbsp;</td><td>pointer to a time stamp representing the interval end times </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arrEventCount</em>&nbsp;</td><td>array (size = 128) to store the event counts. In the case of </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2fd3da3ee812839b662414e0225ebb31"></a><!-- doxytag: member="CMCSAStream::GetADBits" ref="a2fd3da3ee812839b662414e0225ebb31" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short CMCSAStream::GetADBits </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get number of AD bits. </p>
<p>Get number of bits of the analog digital (AD) converter. For MC_Card it is either 12 or 16 </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of AD bits </dd></dl>

</div>
</div>
<a class="anchor" id="add0777a46fc354dc7bf80fafbf090c63"></a><!-- doxytag: member="CMCSAStream::GetADZero" ref="add0777a46fc354dc7bf80fafbf090c63" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD CMCSAStream::GetADZero </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the AD zero value. </p>
<p>Get the AD value representing 0. For 12 bits the AD range is 0 .. 4095, AD zero is 2048. For 16 bits the range is 0 .. 65535, AD zero is 32768 </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>AD zero value </dd></dl>

</div>
</div>
<a class="anchor" id="a5b1e82dbe9560579310d584b045e5a15"></a><!-- doxytag: member="CMCSAStream::GetBufferID" ref="a5b1e82dbe9560579310d584b045e5a15" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * CMCSAStream::GetBufferID </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the ID of the stream. </p>
<p>The ID of the stream consists of four characters (short cut of the stream name) and a four character number (0001, 0002, ...). <br/>
 The following names are defined (as of MCStream.dll V 3.2): </p>
<table class="doxtable">
<tr>
<td>elec </td><td>Electrode raw data  </td></tr>
<tr>
<td>anlg </td><td>Analog raw data  </td></tr>
<tr>
<td>digi </td><td>Digital raw data  </td></tr>
<tr>
<td>spks </td><td>Spikes  </td></tr>
<tr>
<td>filt </td><td>Filtered data  </td></tr>
<tr>
<td>trig </td><td>Triggered data (sweeps)  </td></tr>
<tr>
<td>para </td><td>Analyzer data (Parameters)  </td></tr>
<tr>
<td>mean </td><td>Averager data  </td></tr>
<tr>
<td>sppa </td><td>Spike analyzer data  </td></tr>
</table>
<p>This identifier is unique for a given mcd file </p>

</div>
</div>
<a class="anchor" id="a35f187575116d2d91117c02a6f954737"></a><!-- doxytag: member="CMCSAStream::GetChannel" ref="a35f187575116d2d91117c02a6f954737" args="(short Index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_m_c_s_a_channel.html">CMCSAChannel</a> * CMCSAStream::GetChannel </td>
          <td>(</td>
          <td class="paramtype">short&nbsp;</td>
          <td class="paramname"> <em>Index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the channel object. </p>
<p>Eeach data stream consists of 1 to many channels. Using <a class="el" href="class_c_m_c_s_a_stream.html#a4e06866a2f45b4df9fc5f13b6657fc47" title="Get stream channel count.">GetChannelCount()</a>, and <a class="el" href="class_c_m_c_s_a_stream.html#a35f187575116d2d91117c02a6f954737" title="Get the channel object.">GetChannel()</a>, channel specific information can be obtained (see example code below). </p>
<div class="fragment"><pre class="fragment"><span class="keywordflow">for</span>(<span class="keywordtype">long</span> i = 0; i &lt; m_MCSStream.GetChannelCount(); ++i)
{
    IMCSChannel Channel;
    Channel.AttachDispatch(m_MCSStream.GetChannel(i));
    CString csChName = Channel.GetName();
    <span class="keywordtype">short</span> iChHWID = Channel.GetHwid();
    <span class="keywordtype">short</span> iChBufferIndex = Channel.GetId();
    <span class="keywordtype">short</span> iChGroupID = Channel.GetGroupID();
    Channel.ReleaseDispatch();
}
</pre></div> 
</div>
</div>
<a class="anchor" id="a4e06866a2f45b4df9fc5f13b6657fc47"></a><!-- doxytag: member="CMCSAStream::GetChannelCount" ref="a4e06866a2f45b4df9fc5f13b6657fc47" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long CMCSAStream::GetChannelCount </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get stream channel count. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>channel count </dd></dl>

</div>
</div>
<a class="anchor" id="acb78c11c727e9b935361779ba15b1041"></a><!-- doxytag: member="CMCSAStream::GetChannelName" ref="acb78c11c727e9b935361779ba15b1041" args="(short Index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * CMCSAStream::GetChannelName </td>
          <td>(</td>
          <td class="paramtype">short&nbsp;</td>
          <td class="paramname"> <em>Index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get name of the channel. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Name of the channel </dd></dl>

</div>
</div>
<a class="anchor" id="a107b166825e5199391e29a243eaf5114"></a><!-- doxytag: member="CMCSAStream::GetChunkNextTo" ref="a107b166825e5199391e29a243eaf5114" args="(CMCSATimeStamp *ts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CMCSAChunk * CMCSAStream::GetChunkNextTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_m_c_s_a_time_stamp.html">CMCSATimeStamp</a> *&nbsp;</td>
          <td class="paramname"> <em>ts</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get chunk object which is next to a time stamp. </p>
<p>Moves in the file to the data chunk next to the time stamp. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ts</em>&nbsp;</td><td>time stamp </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to the chunk object next to time stamp </dd></dl>

</div>
</div>
<a class="anchor" id="a92e6644b54f3566a049af6fb5c47f5a3"></a><!-- doxytag: member="CMCSAStream::GetDataType" ref="a92e6644b54f3566a049af6fb5c47f5a3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * CMCSAStream::GetDataType </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get data type. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>zero terminated string with maximum of 8 characters: <ul>
<li>
params  </li>
<li>
average  </li>
<li>
trigger  </li>
<li>
filter  </li>
<li>
spikes  </li>
<li>
analog  </li>
<li>
digital  </li>
<li>
spkparam  </li>
<li>
bstparam  </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ae63923e76c26a4f3d80b70da81736ded"></a><!-- doxytag: member="CMCSAStream::GetDefaultSamplesPerSegment" ref="ae63923e76c26a4f3d80b70da81736ded" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short CMCSAStream::GetDefaultSamplesPerSegment </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the number of samples of a data segment. </p>
<p>This method is only important for MC_Rack </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of samples per data segment </dd></dl>

</div>
</div>
<a class="anchor" id="a64ac39d0816a3bac583b67961b72c563"></a><!-- doxytag: member="CMCSAStream::GetDefaultSegmentCount" ref="a64ac39d0816a3bac583b67961b72c563" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short CMCSAStream::GetDefaultSegmentCount </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the number of data segments. </p>
<p>This method is only important for MC_Rack </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of data segments </dd></dl>

</div>
</div>
<a class="anchor" id="a741dc87881ed373730411715d74f2611"></a><!-- doxytag: member="CMCSAStream::GetEventNextTo" ref="a741dc87881ed373730411715d74f2611" args="(CMCSATimeStamp *ts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_m_c_s_a_event.html">CMCSAEvent</a> * CMCSAStream::GetEventNextTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_m_c_s_a_time_stamp.html">CMCSATimeStamp</a> *&nbsp;</td>
          <td class="paramname"> <em>ts</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Move to Event next ot the stime stamp. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ts</em>&nbsp;</td><td>Time stamp </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Event object next to time stamp </dd></dl>

</div>
</div>
<a class="anchor" id="ae3c62748efff5b2c92e70b069af88eca"></a><!-- doxytag: member="CMCSAStream::GetFirstChunk" ref="ae3c62748efff5b2c92e70b069af88eca" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CMCSAChunk * CMCSAStream::GetFirstChunk </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get first data chunk. </p>
<p>Get the first data chunk of the current stream. See the example code below how to read in the data chunks of a stream. </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> CTestDLLDoc::ReadRawDataChunks()
{
<span class="comment">// DP 02/2003</span>
<span class="comment">// this method describes the principle of reading raw data chunks</span>
<span class="comment">// from an MC_Rack data file by reading the file chunks (segments</span>
<span class="comment">// of maximal 100ms data). In a real import method the code</span>
<span class="comment">// has to be optimized for speed!!</span>

    <span class="keywordtype">int</span> iStreamHdrVersion = m_MCSStream.GetHeaderVersion();

  <span class="comment">// determine values for conversion of AD-values to voltages</span>
  <span class="keywordtype">int</span> iADBits = m_MCSStream.GetADBits();
  <span class="keywordtype">int</span> iADZero = m_MCSStream.GetADZero();
  <span class="keywordtype">char</span> cUnitSign = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(m_MCSStream.GetUnitSign());
  <span class="keywordtype">float</span> fUnitsPerAD = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(m_MCSStream.GetUnitsPerAD());

    <span class="keywordtype">long</span> lChannelCount = m_MCSStream.GetChannelCount();
    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; lChannelCount; ++i)
    {
        CString csChannelName = m_MCSStream.GetChannelName(i);
    }

    LPDISPATCH lpdChunk;

    IMCSChunk* pChunk = <span class="keyword">new</span> IMCSChunk;
    lpdChunk = m_MCSStream.GetFirstChunk();

    <span class="keywordflow">if</span>(lpdChunk)
    {
        pChunk-&gt;AttachDispatch(lpdChunk);
    }
    
    <span class="keywordflow">while</span>(lpdChunk)
    {
        IMCSTimeStamp ChunkFrom;
        LPDISPATCH lpd = pChunk-&gt;GetTimeStampFrom();
        ChunkFrom.AttachDispatch(lpd);
        <span class="keywordtype">int</span> iSeconds = ChunkFrom.GetSecondFromStart();
        <span class="keywordtype">int</span> iMilliS = ChunkFrom.GetMillisecondFromStart();
        <span class="keywordtype">int</span> iMicroS = ChunkFrom.GetMicrosecondFromStart();
        <span class="keywordtype">int</span> iNanoS = ChunkFrom.GetNanosecondFromStart();
        ChunkFrom.ReleaseDispatch();

        <span class="keywordtype">float</span> fChunkFrom = iSeconds +
                                                        <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(iMilliS) / 1000 +
                                                        static_cast&lt;float&gt;(iMicroS) / 1000000 +
                                                        <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(iNanoS) / 1000000000;

        IMCSTimeStamp ChunkTo;
        lpd = pChunk-&gt;GetTimeStampTo();
        ChunkTo.AttachDispatch(lpd);
        iSeconds = ChunkTo.GetSecondFromStart();
        iMilliS = ChunkTo.GetMillisecondFromStart();
        iMicroS = ChunkTo.GetMicrosecondFromStart();
        iNanoS = ChunkTo.GetNanosecondFromStart();
        ChunkTo.ReleaseDispatch();

        <span class="keywordtype">float</span> fChunkTo = iSeconds +
                                                        <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(iMilliS) / 1000 +
                                                        static_cast&lt;float&gt;(iMicroS) / 1000000 +
                                                        <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(iNanoS) / 1000000000;

        <span class="keywordtype">long</span> lBufferSize = pChunk-&gt;GetSize();
        <span class="keywordtype">short</span>* pBuffer = <span class="keyword">new</span> <span class="keywordtype">short</span>[lBufferSize];
        <span class="keywordflow">if</span>(lBufferSize != pChunk-&gt;ReadData(pBuffer))
        {
            ASSERT(0);
        }

        <span class="keywordtype">float</span>* pMicroVolts = <span class="keyword">new</span> <span class="keywordtype">float</span>[lBufferSize];

        <span class="keywordflow">for</span>(i = 0; i &lt; lBufferSize; ++i)
        {
            *(pMicroVolts + i) = (*(pBuffer + i) - iADZero) * fUnitsPerAD;
        }
        
        <span class="keyword">delete</span> pBuffer;
        <span class="keyword">delete</span> pMicroVolts;
        lpdChunk = m_MCSStream.GetNextChunk(lpdChunk);
    }

    pChunk-&gt;ReleaseDispatch();
    <span class="keyword">delete</span> pChunk;
}
</pre></div> <dl class="return"><dt><b>Returns:</b></dt><dd>pointer to a chunk object </dd></dl>

</div>
</div>
<a class="anchor" id="af040546102ff1684bac6a422cea3f35b"></a><!-- doxytag: member="CMCSAStream::GetFirstEvent" ref="af040546102ff1684bac6a422cea3f35b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_m_c_s_a_event.html">CMCSAEvent</a> * CMCSAStream::GetFirstEvent </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get first event of data stream. </p>
<p>See example code below for how to use the stream events to access data. For raw data use the GetRaw..., or GetSweep... methods. </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> CTestDLLDoc::ReadSpikes()
{
<span class="comment">// DP 01/2003</span>
<span class="comment">// this method describes the principle of reading spike data</span>
<span class="comment">// from an MC_Rack data file. In a real import method the code</span>
<span class="comment">// has to be optimized for speed!!</span>

  <span class="comment">// determine values for conversion of AD-values to voltages</span>
  <span class="keywordtype">int</span> iADZero = m_MCSStream.GetADZero();
  <span class="keywordtype">char</span> cUnitSign = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(m_MCSStream.GetUnitSign());
  <span class="keywordtype">float</span> fUnitsPerAD = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(m_MCSStream.GetUnitsPerAD());

    IMCSEvtSpike EventSpike; 
  EventSpike.AttachDispatch(m_MCSStream.GetFirstEvent());
  <span class="keywordtype">int</span> iContinue = 1;
      
  <span class="comment">// loop over all events</span>
  <span class="keywordflow">while</span> (iContinue == 1)
    {
        <span class="keywordtype">int</span> iUnitID = EventSpike.GetUnitID(); <span class="comment">//if 0 spike is not classified</span>

    <span class="keywordtype">int</span> iSeconds = EventSpike.GetSecondFromStart();
    <span class="keywordtype">int</span> iMilliS = EventSpike.GetMillisecondFromStart();
    <span class="keywordtype">int</span> iMicroS = EventSpike.GetMicrosecondFromStart();
    <span class="keywordtype">int</span> iNanoS = EventSpike.GetNanosecondFromStart();

        <span class="keywordtype">float</span> fSpikeTimeStamp = iSeconds +
                                                        <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(iMilliS) / 1000 +
                                                        static_cast&lt;float&gt;(iMicroS) / 1000000 +
                                                        <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(iNanoS) / 1000000000;


        <span class="keywordtype">int</span> iChannel = EventSpike.GetChannel();
        CString csChannelName = m_MCSStream.GetChannelName(iChannel);

    <span class="keywordtype">int</span> iPreTick = EventSpike.GetPreEvent();
        <span class="keywordtype">int</span> iSpikeDataArraySize = EventSpike.GetCount();
        <span class="keywordtype">short</span>* SpikeDataBuffer = <span class="keyword">new</span> <span class="keywordtype">short</span>[iSpikeDataArraySize];
        EventSpike.GetADDataArray(SpikeDataBuffer);

    <span class="comment">// compute Voltage from iADData</span>
        <span class="keywordtype">float</span>* Spike = <span class="keyword">new</span> <span class="keywordtype">float</span>[iSpikeDataArraySize];
        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; iSpikeDataArraySize; ++i)
        {
            *(Spike + i) = (*(SpikeDataBuffer + i) - iADZero) * fUnitsPerAD;
        }
    <span class="keyword">delete</span> [] Spike;
                                      
    <span class="comment">// move to next event</span>
        <span class="keyword">delete</span> [] SpikeDataBuffer;
    iContinue = EventSpike.Next();
  }
  EventSpike.ReleaseDispatch();
}
</pre></div> <dl class="return"><dt><b>Returns:</b></dt><dd>Event object </dd></dl>

</div>
</div>
<a class="anchor" id="a679fd670f9b7e6bf4aee17c6620c5b0e"></a><!-- doxytag: member="CMCSAStream::GetFormatVersion" ref="a679fd670f9b7e6bf4aee17c6620c5b0e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short CMCSAStream::GetFormatVersion </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get format version. </p>
<p>The format version is used for backward compartibility. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>format version </dd></dl>

</div>
</div>
<a class="anchor" id="aa2e42b0b232ed753c8dafccfa5a33dc7"></a><!-- doxytag: member="CMCSAStream::GetHeaderVersion" ref="aa2e42b0b232ed753c8dafccfa5a33dc7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long CMCSAStream::GetHeaderVersion </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get stream header version. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Header versione of the stream header </dd></dl>

</div>
</div>
<a class="anchor" id="a5ef6e8abb21099311db3e4ea93f33c4b"></a><!-- doxytag: member="CMCSAStream::GetInfo" ref="a5ef6e8abb21099311db3e4ea93f33c4b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * CMCSAStream::GetInfo </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get Info object of the stream. </p>
<p>Most streams have a info object, which provides information about the data stream. See example below how to access the info object. </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> CTestDLLDoc::ReadSpikeInfo()
{
<span class="comment">// DP 01/2003</span>
<span class="comment">// this method describes the principle of reading spike info</span>
<span class="comment">// from an MC_Rack data file. In a real import method the code</span>
<span class="comment">// has to be optimized!!</span>

    IMCSInfoSpike InfoSpike;

    InfoSpike.AttachDispatch(m_MCSStream.GetInfo());
    
    <span class="keywordtype">short</span> iDetectMethod = InfoSpike.GetDetectMethod();
    <span class="keywordtype">short</span> iSortMethod = InfoSpike.GetSortMethod();
    <span class="keywordtype">float</span> fPreTrigger = InfoSpike.GetPreTrigger();
    <span class="keywordtype">float</span> fPostTrigger = InfoSpike.GetPostTrigger();
    <span class="keywordtype">float</span> fDeadTime = InfoSpike.GetDeadTime();

    <span class="keywordflow">for</span>(<span class="keywordtype">long</span> i = 0; i &lt; m_MCSStream.GetChannelCount(); ++i)
    {
        IMCSChannel Channel;
        Channel.AttachDispatch(m_MCSStream.GetChannel(i));
        <span class="keywordtype">short</span> iChHWID = Channel.GetHwid();
        <span class="keywordtype">short</span> iChBufferIndex = Channel.GetId();
        Channel.ReleaseDispatch();

        <span class="keywordtype">short</span> iChannelGroupID = InfoSpike.GetChannelGroupID(iChHWID);
        <span class="keywordtype">float</span> fThresholdLevel = InfoSpike.GetThresholdLevel(iChHWID);
        <span class="keywordtype">short</span> iThresholdSlope = InfoSpike.GetThresholdSlope(iChHWID);
        <span class="keywordtype">float</span> fSlopeDeltaV = InfoSpike.GetSlopeDeltaV(iChHWID);
        <span class="keywordtype">float</span> fSlopeMin = InfoSpike.GetSlopeMin(iChHWID);
        <span class="keywordtype">float</span> fSlopeMax = InfoSpike.GetSlopeMax(iChHWID);

        <span class="keywordtype">short</span> iUnitCount = InfoSpike.GetSpikeUnitCount();
        <span class="keywordflow">for</span>( <span class="keywordtype">short</span> j = 0; j &lt; iUnitCount; ++j)
        {
            <span class="keywordtype">short</span> iUnitID = InfoSpike.GetSpikeUnitID(j);
            <span class="keywordtype">float</span> fSpikeUnitWndTime = InfoSpike.GetSpikeUnitWndTime(iChHWID, iUnitID);
            <span class="keywordtype">float</span> fSpikeUnitWndMin = InfoSpike.GetSpikeUnitWndMin(iChHWID, iUnitID);
            <span class="keywordtype">float</span> fSpikeUnitWndMax = InfoSpike.GetSpikeUnitWndMax(iChHWID, iUnitID);
        }
    }
    InfoSpike.ReleaseDispatch();
}
</pre></div> <dl class="return"><dt><b>Returns:</b></dt><dd>stream info object </dd></dl>

</div>
</div>
<a class="anchor" id="a7d0d83d67d41ab90c7dd9666626e4b8a"></a><!-- doxytag: member="CMCSAStream::GetMilliSamplesPerSecond" ref="a7d0d83d67d41ab90c7dd9666626e4b8a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long CMCSAStream::GetMilliSamplesPerSecond </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get milli samples per second. </p>
<p>Devide the retrun value by 1000 to convert it to the common sample rate. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>sample of the stream data (mulitplied by 1000) </dd></dl>

</div>
</div>
<a class="anchor" id="aed6661d2f2b5ffeff41f24031c542639"></a><!-- doxytag: member="CMCSAStream::GetName" ref="aed6661d2f2b5ffeff41f24031c542639" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * CMCSAStream::GetName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get data stream name. </p>
<p>Get stream name, for example "Electrode Raw Data" or "Digital Raw Data". </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>zero terminated string (max. size 256 characters) </dd></dl>

</div>
</div>
<a class="anchor" id="a50dfa6dd49f476938b95c2a227bf0c85"></a><!-- doxytag: member="CMCSAStream::GetNextChunk" ref="a50dfa6dd49f476938b95c2a227bf0c85" args="(CMCSAChunk *pCurrentChunk)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CMCSAChunk * CMCSAStream::GetNextChunk </td>
          <td>(</td>
          <td class="paramtype">CMCSAChunk *&nbsp;</td>
          <td class="paramname"> <em>pCurrentChunk</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get next chunk object. </p>
<p>See example code for the GetFistChunk() method. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to the next chunk object </dd></dl>

</div>
</div>
<a class="anchor" id="aa37b1d647d254f0c748df28860a35230"></a><!-- doxytag: member="CMCSAStream::GetNextEvent" ref="aa37b1d647d254f0c748df28860a35230" args="(CMCSAEvent *pCurrentEvent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_m_c_s_a_event.html">CMCSAEvent</a> * CMCSAStream::GetNextEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_m_c_s_a_event.html">CMCSAEvent</a> *&nbsp;</td>
          <td class="paramname"> <em>pCurrentEvent</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Move to next Event. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Event object </dd></dl>

</div>
</div>
<a class="anchor" id="a8ef0cc6315fb182e2bdad9454387a88b"></a><!-- doxytag: member="CMCSAStream::GetRawData" ref="a8ef0cc6315fb182e2bdad9454387a88b" args="(short *pData, long DataSize, CMCSATimeStamp *tsFrom, CMCSATimeStamp *tsTo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long CMCSAStream::GetRawData </td>
          <td>(</td>
          <td class="paramtype">short *&nbsp;</td>
          <td class="paramname"> <em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>DataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_m_c_s_a_time_stamp.html">CMCSATimeStamp</a> *&nbsp;</td>
          <td class="paramname"> <em>tsFrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_m_c_s_a_time_stamp.html">CMCSATimeStamp</a> *&nbsp;</td>
          <td class="paramname"> <em>tsTo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get raw data. </p>
<p>GetRawData(short* pData, long lFrom, long lTo) swiftly reads raw data streams This method is for continuous raw data (type = analog, electrode, digital, filtered) For triggered raw data use the GetSweep... methods, for all other data use the event based reading routines. </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> CTestDLLDoc::ReadRawData(__int64 i64From, __int64 i64To) <span class="comment">// in s</span>
{
<span class="comment">// DP 02/2003</span>
<span class="comment">// this method describes the principle of reading raw data</span>
<span class="comment">// from an MC_Rack data file. In a real import method the code</span>
<span class="comment">// has to be optimized for speed!!</span>

    <span class="keywordflow">if</span>(m_MCSStream.HasRawData() &amp;&amp; m_MCSStream.HasContinuousData())
    {
        <span class="comment">// set time stamps</span>
        <span class="keywordtype">long</span> lFromSec=(long)(i64From / 1000000);
        <span class="keywordtype">short</span> sFromMSec=(short)((i64From - (DWORDLONG)lFromSec * 1000000) / 1000);
        <span class="keywordtype">short</span> sFromUSec=(short)((i64From - (DWORDLONG)lFromSec * 1000000 - (DWORDLONG)sFromMSec * 1000));
        <span class="keywordtype">short</span> sFromNSec = 0;

        <span class="keywordtype">long</span> lToSec=(long)(i64To / 1000000);
        <span class="keywordtype">short</span> sToMSec=(short)((i64To - (DWORDLONG)lToSec * 1000000) / 1000);
        <span class="keywordtype">short</span> sToUSec=(short)((i64To - (DWORDLONG)lToSec * 1000000 - (DWORDLONG)sToMSec * 1000));
        <span class="keywordtype">short</span> sToNSec = 0;

        IMCSTimeStamp tsFrom,tsTo;
        tsTo.AttachDispatch(m_MCSFile.GetStartTime());
        tsFrom.AttachDispatch(tsTo.Clone());
        tsFrom.SetSecondFromStart(lFromSec);
        tsFrom.SetMillisecondFromStart(sFromMSec);
        tsFrom.SetMicrosecondFromStart(sFromUSec);
        tsFrom.SetNanosecondFromStart(sFromNSec);
        tsTo.ReleaseDispatch();
        tsTo.AttachDispatch(tsFrom.Clone());
        tsTo.SetSecondFromStart(lToSec);
        tsTo.SetMillisecondFromStart(sToMSec);
        tsTo.SetMicrosecondFromStart(sToUSec);
        tsTo.SetNanosecondFromStart(sToNSec);

        <span class="keywordtype">long</span> lBufferSize = m_MCSStream.GetRawDataBufferSize(tsFrom, tsTo);
        <span class="keywordtype">short</span>* pBuffer = <span class="keyword">new</span> <span class="keywordtype">short</span>[lBufferSize];
        
        <span class="keywordflow">if</span>(lBufferSize != m_MCSStream.GetRawData(pBuffer, tsFrom, tsTo))
        {
            ASSERT(0);
        }
        <span class="keyword">delete</span> [] pBuffer;
    }
}
</pre></div> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pData</em>&nbsp;</td><td>pointer to data array of shorts (size must be determined before calling GetData. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tsFrom,:</em>&nbsp;</td><td>TimeStamp start reading in ns relative to start recording. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tsTo,:</em>&nbsp;</td><td>TimeStamp end reading in ns relative to start recording. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of Data values read from the file, 0 if data is not a raw data stream </dd></dl>

</div>
</div>
<a class="anchor" id="adf45469b4fefdf17eb745421384afc78"></a><!-- doxytag: member="CMCSAStream::GetRawDataBufferSize" ref="adf45469b4fefdf17eb745421384afc78" args="(CMCSATimeStamp *tsFrom, CMCSATimeStamp *tsTo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long CMCSAStream::GetRawDataBufferSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_m_c_s_a_time_stamp.html">CMCSATimeStamp</a> *&nbsp;</td>
          <td class="paramname"> <em>tsFrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_m_c_s_a_time_stamp.html">CMCSATimeStamp</a> *&nbsp;</td>
          <td class="paramname"> <em>tsTo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get buffer size. </p>
<p>GetRawDataBufferSize(long lFrom, long lTo) called to determine the required buffer size This method is for continuous raw data (type = analog, electrode, digital, filtered). For triggered raw data use the GetSweep... methods, for all other data use the event based reading routines. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tsFrom,:</em>&nbsp;</td><td>start reading in ns relative to start recording. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tsTo,:</em>&nbsp;</td><td>end reading in ns relative to start recording. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>size of buffer (shorts). Retuns 0 if the stream has no raw data or is triggered. </dd></dl>

</div>
</div>
<a class="anchor" id="a2655f49081adfd399e5614b29babffda"></a><!-- doxytag: member="CMCSAStream::GetRawDataBufferSizeOfChannel" ref="a2655f49081adfd399e5614b29babffda" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long CMCSAStream::GetRawDataBufferSizeOfChannel </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get buffer size needed for a single channel. </p>
<p><a class="el" href="class_c_m_c_s_a_stream.html#a2655f49081adfd399e5614b29babffda" title="Get buffer size needed for a single channel.">GetRawDataBufferSizeOfChannel()</a> called to determine for a single channel the required buffer size This method is for continuous raw data (type = analog, electrode, digital, filtered). For triggered raw data use the GetSweep... methods, for all other data use the event based reading routines. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>size of buffer (shorts). Retuns 0 if the stream has no raw data or is triggered. </dd></dl>

</div>
</div>
<a class="anchor" id="af408ce74713960b065fe558f92ca9294"></a><!-- doxytag: member="CMCSAStream::GetRawDataOfChannel" ref="af408ce74713960b065fe558f92ca9294" args="(short *pData, long lIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long CMCSAStream::GetRawDataOfChannel </td>
          <td>(</td>
          <td class="paramtype">short *&nbsp;</td>
          <td class="paramname"> <em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>lIndex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get raw data of a single channel. </p>
<p><a class="el" href="class_c_m_c_s_a_stream.html#af408ce74713960b065fe558f92ca9294" title="Get raw data of a single channel.">GetRawDataOfChannel(short* pData, long lIndex)</a> swiftly reads raw data of channel lIndex This method is for continuous raw data (type = analog, electrode, digital, filtered) For triggered raw data use the GetSweep... methods, for all other data use the event based reading routines. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pData</em>&nbsp;</td><td>pointer to data array of shorts (size must be determined before calling GetData. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lIndex,:</em>&nbsp;</td><td>index to channel (starts with zero!) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of Data values read from the file, 0 if data is not a raw data stream (analog, electrode, digital, filtered) or triggered </dd></dl>

</div>
</div>
<a class="anchor" id="ac1f2da251f43b536181fd300b9ce6061"></a><!-- doxytag: member="CMCSAStream::GetRawDataOfChannelStartCount" ref="ac1f2da251f43b536181fd300b9ce6061" args="(short *pData, long lIndex, long lStart, long lCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long CMCSAStream::GetRawDataOfChannelStartCount </td>
          <td>(</td>
          <td class="paramtype">short *&nbsp;</td>
          <td class="paramname"> <em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>lIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>lStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>lCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get raw data of a single channel. </p>
<p><a class="el" href="class_c_m_c_s_a_stream.html#ac1f2da251f43b536181fd300b9ce6061" title="Get raw data of a single channel.">GetRawDataOfChannelStartCount(short* pData, long lIndex, long lStart, long lCount)</a> swiftly reads raw data of channel lIndex, starting at lStart sample lCount values. This method is for continuous raw data (type = analog, electrode, digital, filtered) For triggered raw data use the GetSweep... methods, for all other data use the event based reading routines. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pData</em>&nbsp;</td><td>pointer to data array of shorts (size must be determined and memory provided before calling GetData). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lIndex,:</em>&nbsp;</td><td>index to channel (starts with zero!) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lStart</em>&nbsp;</td><td>index of sample to start from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lCount</em>&nbsp;</td><td>number of samples to get </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of Data values read from the file, 0 if data is not a raw data stream (analog, electrode, digital, filtered) or triggered </dd></dl>

</div>
</div>
<a class="anchor" id="ac4f2b9b7ca3ee10c461b6c32a0b4021a"></a><!-- doxytag: member="CMCSAStream::GetRelativeChannelPosX" ref="ac4f2b9b7ca3ee10c461b6c32a0b4021a" args="(short Index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CMCSAStream::GetRelativeChannelPosX </td>
          <td>(</td>
          <td class="paramtype">short&nbsp;</td>
          <td class="paramname"> <em>Index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get x channel position in a range from 0 (left) to 100 (right). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Index</em>&nbsp;</td><td>the channel index </td></tr>
  </table>
  </dd>
</dl>
<dl class="attention"><dt><b>Attention:</b></dt><dd>this might not be the same as the relative position from the layout if not all channels of the MEA are in the stream </dd></dl>

</div>
</div>
<a class="anchor" id="a8f7b177b30fa7d1d0c80a918e0576a58"></a><!-- doxytag: member="CMCSAStream::GetRelativeChannelPosY" ref="a8f7b177b30fa7d1d0c80a918e0576a58" args="(short Index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CMCSAStream::GetRelativeChannelPosY </td>
          <td>(</td>
          <td class="paramtype">short&nbsp;</td>
          <td class="paramname"> <em>Index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get y channel position in a range from 0 (top) to 100 (bottom). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Index</em>&nbsp;</td><td>the channel index </td></tr>
  </table>
  </dd>
</dl>
<dl class="attention"><dt><b>Attention:</b></dt><dd>this might not be the same as the relative position from the layout if not all channels of the MEA are in the stream </dd></dl>

</div>
</div>
<a class="anchor" id="a2c09efef329e2795e536c956d4e2c5f5"></a><!-- doxytag: member="CMCSAStream::GetSampleRate" ref="a2c09efef329e2795e536c956d4e2c5f5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long CMCSAStream::GetSampleRate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get sample rate in Hz. </p>
<p>returns 0 in case of error </p>

</div>
</div>
<a class="anchor" id="a2a895dd2e28561cdfab84262946e4fb6"></a><!-- doxytag: member="CMCSAStream::GetSweepRawData" ref="a2a895dd2e28561cdfab84262946e4fb6" args="(short *pData, long DataSize, long lSweepIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long CMCSAStream::GetSweepRawData </td>
          <td>(</td>
          <td class="paramtype">short *&nbsp;</td>
          <td class="paramname"> <em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>DataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>lSweepIndex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get sweep data. </p>
<p>This method is for triggered raw data (type = analog, electrode, digital, filtered) For continuous raw data use the GetData... methods, for all other data use the event based reading routines. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pData</em>&nbsp;</td><td>pointer to data array of shorts (size must be determined beforehand). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lSweepIndex</em>&nbsp;</td><td>defines which sweep is accessed </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the next triggered data block was read; false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a0e062ed292a5af93b861edb670e5aae8"></a><!-- doxytag: member="CMCSAStream::GetSweepRawDataBufferSize" ref="a0e062ed292a5af93b861edb670e5aae8" args="(long lSweepIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long CMCSAStream::GetSweepRawDataBufferSize </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>lSweepIndex</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get buffer size neede for a sweep. </p>
<p><a class="el" href="class_c_m_c_s_a_stream.html#a0e062ed292a5af93b861edb670e5aae8" title="Get buffer size neede for a sweep.">GetSweepRawDataBufferSize()</a> called to determine the required buffer size for a single sweep of triggered data This method is for triggered raw data (type = analog, electrode, digital, filtered) For continuous raw data use the GetData... methods, for all other data use the event based reading routines. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>size of buffer (shorts). Retuns 0 if the stream has no raw data or is continuous. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ddd2a90c00efeef133e7d86f82907f5"></a><!-- doxytag: member="CMCSAStream::GetSweepRawDataOfChannel" ref="a2ddd2a90c00efeef133e7d86f82907f5" args="(short *pData, long sweepsize, long lSweepIndex, long lIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long CMCSAStream::GetSweepRawDataOfChannel </td>
          <td>(</td>
          <td class="paramtype">short *&nbsp;</td>
          <td class="paramname"> <em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>sweepsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>lSweepIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>lIndex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get sweep data of a single channel. </p>
<p>This method is for triggered raw data (type = analog, electrode, digital, filtered) For continuous raw data use the GetData... methods, for all other data use the event based reading routines. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pData</em>&nbsp;</td><td>pointer to data array of shorts (size must be determined beforehand). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lSweepIndex</em>&nbsp;</td><td>defines which sweep is accessed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lIndex</em>&nbsp;</td><td>channel index </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the next triggered data block was read; false if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a8963396e7b65de404b09b7480eb1ce2c"></a><!-- doxytag: member="CMCSAStream::GetUnitSign" ref="a8963396e7b65de404b09b7480eb1ce2c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short CMCSAStream::GetUnitSign </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get unit sign. </p>
<p>Get the unit sign of the stream data. The return value of the <a class="el" href="class_c_m_c_s_a_stream.html#a8963396e7b65de404b09b7480eb1ce2c" title="Get unit sign.">GetUnitSign()</a> has to be casted to char (see demo code below). </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">char</span> cUnitSign = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(m_MCSStream.GetUnitSign());
</pre></div> <dl class="return"><dt><b>Returns:</b></dt><dd>char, for example 'V' for volt </dd></dl>

</div>
</div>
<a class="anchor" id="a2d2323c977c875baf50f4dabd544cdb7"></a><!-- doxytag: member="CMCSAStream::GetUnitsPerAD" ref="a2d2323c977c875baf50f4dabd544cdb7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CMCSAStream::GetUnitsPerAD </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get units per AD step. </p>
<p>Get the unit value for a AD value step. Depending on the number of AD bits, the input voltage range, and the amplifier gain <a class="el" href="class_c_m_c_s_a_stream.html#a2d2323c977c875baf50f4dabd544cdb7" title="Get units per AD step.">GetUnitsPerAD()</a> returns the units per step. For example 0.833V per step, when the range was set to -4086mV to 4085mV, and the gain was 1200 (typical for a MEA amplifier). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>units per AD step </dd></dl>

</div>
</div>
<a class="anchor" id="a52fca28b0eb49e718d83bcfed697ef8d"></a><!-- doxytag: member="CMCSAStream::HasContinuousData" ref="a52fca28b0eb49e718d83bcfed697ef8d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CMCSAStream::HasContinuousData </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Has data stream continuous data. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>
true if data is continuous  </li>
<li>
false if the data is triggered  </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a478aebe07348a029debfea838bbdea6a"></a><!-- doxytag: member="CMCSAStream::HasRawData" ref="a478aebe07348a029debfea838bbdea6a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CMCSAStream::HasRawData </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Has data stream raw data. </p>
<p>MC_Rack raw data pools the data types 'analog', 'filter', and 'digital'. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>
true if stream contain raw data ('analog', 'filter', and 'digital')  </li>
<li>
false if stream contain other data  </li>
</ul>
</dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Oct 19 2010 16:59:50 for MCStream DLL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
