<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>MC_Stream DLL: Main Page</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="mcsdox.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>MCStream DLL Documentation</h1>  </div>
</div>
<div class="contents">
<h3 class="version">V 3.5 </h3><p>This documentation and the examples are published with MC_Rack V 3.5. For updates or questions please visit our homepage <a href="http://www.multichannelsystems.com">Multi Channel Systems</a> or contact <a href="mailto:support@multichannelsystems.com">support@multichannelsystems.com</a>.</p>
<h2><a class="anchor" id="intro"></a>
Introduction</h2>
<p>The MCStream Automation Server is a Dynamic Link Library (DLL) named MCStream.dll, which contains code for reading Data Files that were recorded with Multi Channel System's data acquisition software MC_Rack. The code in the DLL can be called from any Windows program which can access objects of an OLE Automation Server. Such programs can be written, e.g. in Visual Basic, Visual C++, Borland C++, and many other programming languages.</p>
<p>The MCStream OLE-Automation Server provides access to Automation Objects, representing MC_Rack data files, data streams in the data file, channels, events (data), and info in the data streams. These objects have attributes which can be read, and methods, which can be executed. The stream object, for example, has an attribute named <code>NumberOfStreams</code>, which gives the number of streams stored in the data file. This object also has a method called <code>OpenFile()</code> to open an MC_Rack data file.</p>
<p>The MCStream OLE-Automation Server can read data from Version 1.70 and higher of MC_Rack, so you don't have to bother learning the (complex) file format of the data files. The DLL contains a lot of code you would have to write yourself, if you wanted to access the data files directly. As the data format of MC_Rack will be adopted from time to time, we will provide new verions of the MCStream Automation Server which can read <b>new</b> and <b>old</b> data formats. There is also code in the DLL patching some header inconsistencies due to resolved MC_Rack bugs.</p>
<p>We provide an ANSI C++ compatible library for reading the data on Linux. It is part of the MCStreamSupport files which are (optionally) installed with MC_Rack. On request we also provide this library for MSVC 8 on Windows.</p>
<h3><a class="anchor" id="objects"></a>
The Object Hierarchy of the MCStream OLE-Automation Server</h3>
<p>The MCStream OLE-Automation Server provides access to objects of six different classes: File, Stream, Channel, Chunk, Event, TimeStamp, Info.</p>
<p>The File object represents a data file written with MC_Rack. It contains zero or more Stream objects, which represent data streams within the file, e.g. raw data, spike data, trigger data, etc.</p>
<p>A data stream has zero or more Channel objects, which contain information about the channels in the stream, most notably the channel name. Usually, you don't need the channel object, because you can access the channel names via the stream object. Stream dependent configuration information can be get as an Info object.</p>
<p>A data stream stores zero or more (usually quite a lot of) Event objects, representing one event or data point. These events are </p>
<ul>
<li>
raw data measured at one point in time at all selected channels </li>
<li>
a spike on one of the selected channels </li>
<li>
a trigger event </li>
<li>
an analyzer event combining the different extracted parameters (min, max) of all selected channels at one time point </li>
<li>
a spike analyzer event combining the extracted parameters of the spike analyzer </li>
</ul>
<p>Internally, these events are stored in groups called Chunks. But usually, you don't need to know about Chunk objects.</p>
<p>Finally, every Event is associated with a TimeStamp object, which gives you the time (Year, Day, Month, Hour, Second, Millisecond, Microsecond, Nanosecond) this event was recorded. For convenience you can access the time of the event via the Event object directly.</p>
<p>Graphically, the object model looks like this:</p>
<div align="center">
<img src="MCStreamHierarchy.gif" alt="MCStreamHierarchy.gif"/>
</div>
<p>The Event class has several subclasses, representing raw data, spikes, trigger events, prameters, .... The subclasses have additional methods and attributes. The method <code>GetFirstEvent()</code> of the stream object returns an object of the appropriate subclass. To determine which object the method GetFirstEvent() will return, look at the DataType attribute of the stream object. There are different info classes for the different DataTypes.</p>
<h3><a class="anchor" id="about"></a>
About this documentation</h3>
<p>In the current version of this documentation the following objects are described:</p>
<ul>
<li>
File: <a class="el" href="class_c_m_c_s_a_stream_file.html" title="Interface for mcd files.">CMCSAStreamFile</a>  </li>
<li>
Stream: <a class="el" href="class_c_m_c_s_a_stream.html" title="Retrieve MC_Rack data stream.">CMCSAStream</a>  </li>
<li>
Channel: <a class="el" href="class_c_m_c_s_a_channel.html" title="Retrieve channel information.">CMCSAChannel</a>  </li>
<li>
Event: <a class="el" href="class_c_m_c_s_a_event.html" title="Retrieve Event Infos.">CMCSAEvent</a> <ul>
<li>
Raw Data Event:  </li>
<li>
Spike Event: <a class="el" href="class_c_m_c_s_a_evt_spike.html" title="Retrieve a spike.">CMCSAEvtSpike</a>  </li>
<li>
Trigger Event: <a class="el" href="class_c_m_c_s_a_evt_trigger.html" title="Trigger event.">CMCSAEvtTrigger</a> </li>
<li>
Average Event:  </li>
<li>
Parameter Event:  </li>
<li>
Spike Parameter Event: <a class="el" href="class_c_m_c_s_a_evt_spike_parameter.html" title="Spike parameter event.">CMCSAEvtSpikeParameter</a> </li>
</ul>
</li>
<li>
Info: <ul>
<li>
Raw Data Info:  </li>
<li>
Filter Info:  </li>
<li>
Spike Info: <a class="el" href="class_c_m_c_s_a_info_spike.html" title="Retrieve Spike infos.">CMCSAInfoSpike</a>  </li>
<li>
Trigger Info: <a class="el" href="class_c_m_c_s_a_info_trigger.html" title="Trigger info.">CMCSAInfoTrigger</a> </li>
<li>
Average Info:  </li>
<li>
Parameter Info:  </li>
<li>
Spike Parameter Info: <a class="el" href="class_c_m_c_s_a_info_spike_parameter.html" title="Info about the data created from the spike parameter instrument.">CMCSAInfoSpikeParameter</a> </li>
</ul>
</li>
<li>
TimeStamp: <a class="el" href="class_c_m_c_s_a_time_stamp.html" title="time stamp class">CMCSATimeStamp</a> </li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>the code for MCStream.dll is divided in two parts <ol>
<li>
ANSI C++ compatible code </li>
<li>
OLE/COM wrapper </li>
</ol>
This documentation is based on the ANSI C++ files. You'll have to change the names of the classes if you use the COM interface:<br/>
 The ANSI C++ classes are named with an additional 'A' compared to the COM interfaces, e.g. the interface for a <a class="el" href="class_c_m_c_s_a_stream.html" title="Retrieve MC_Rack data stream.">CMCSAStream</a> is IMCSStream, for <a class="el" href="class_c_m_c_s_a_time_stamp.html" title="time stamp class">CMCSATimeStamp</a> IMCSTimeStamp etc. TimeStamps of the COM interface are returned as Dispatch not raw pointers<br/>
 (see also the example code)</dd></dl>
<p><br/>
 </p>
<h2><a class="anchor" id="start"></a>
Getting started</h2>
<h3><a class="anchor" id="example"></a>
Example usage</h3>
<p>The MSVC project MC_StreamTest in the MC_StreamSupport directory is provided to help you get started using the MC_Stream.dll. This project was created via the MSVC (Microsoft <span>&copy;</span> Visual C++ 2005) project wizard creating an MFC dialog based application. The example uses ATL CComPtr because it are easier to use than the Dispatch interface of MFC.</p>
<p>The projects allows to open an MC_Rack data file, shows the data stream which were recorded and for each stream the recorded channels. It also shows some info about the stream and channel objects.</p>
<p>The function <code>QuickTestMCDFile()</code> shown here shows how to do all of this in one place. For more realistic code see the file MC_StreamTestDlg.cpp in the example project.</p>
<h3><a class="anchor" id="examplefct"></a>
Example function</h3>
<p>The basic procedure to get to the data is: </p>
<ol>
<li>
open the mcd file </li>
<li>
optionally read some file info, like the start time in the example </li>
<li>
get the number of data streams </li>
<li>
for each desired stream get the number and IDs of the recorded channels </li>
<li>
for each channel read the raw data, either with timestamps from and to or looping over the events <ul>
<li>
create the desired interface for the CComPtr, e.g.<br/>
 <code>m_IStreamFile.CoCreateInstance(_bstr_t("MCSTREAM.MCSSTRM"));</code> <br/>
 MCSTREAM.MCSSTRM is the ProgID of the MCStream.dll  </li>
<li>
use the pointer:<br/>
 <code>short res = m_IStreamFile-&gt;OpenFileEx("Example.mcd");</code>  </li>
</ul>
</li>
</ol>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> CMC_StreamTestDlg::QuickTestMCDFile(<span class="keywordtype">void</span>)
{
    CString strFilter = <span class="stringliteral">&quot;MC_Rack Data (*.mcd)|*.mcd|All Files (*.*)|*.*||&quot;</span>;
    CFileDialog dlg(
        TRUE,
        NULL,
        NULL,
        OFN_HIDEREADONLY | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_NOCHANGEDIR,
        strFilter,
        <span class="keyword">this</span>);

    <span class="keywordflow">if</span> (dlg.DoModal() == IDOK)
    {
        CComPtr&lt;MCStream::IMCSStreamFile&gt; IMcdFile;
        HRESULT hres = IMcdFile.CoCreateInstance(_bstr_t(<span class="stringliteral">&quot;MCSTREAM.MCSSTRM&quot;</span>));
        <span class="keywordflow">if</span> (hres != S_OK)
        {
            MessageBox(<span class="stringliteral">&quot;Could not find registered MCStream.dll&quot;</span>);
            <span class="keywordflow">return</span>;
        }
        <span class="comment">// open the mcd file</span>
        <span class="keywordtype">short</span> res = IMcdFile-&gt;OpenFileEx(_bstr_t(dlg.GetPathName()));
        <span class="keywordflow">if</span> (res != 0)
        {
            CString s;
            s = <span class="stringliteral">&quot;Error loading file: &quot;</span>;
            s += dlg.GetPathName();
            s += <span class="stringliteral">&quot;\n&quot;</span>;

            <span class="keywordflow">switch</span>(res)
            {
            <span class="keywordflow">case</span> 0: <span class="keywordflow">break</span>;
            <span class="keywordflow">case</span> 1: s += <span class="stringliteral">&quot;File can not be opened.&quot;</span>;
                <span class="keywordflow">break</span>;
            <span class="keywordflow">case</span> 2: s += <span class="stringliteral">&quot;Wrong file format.&quot;</span>;
                <span class="keywordflow">break</span>;
            <span class="keywordflow">case</span> 3: s += <span class="stringliteral">&quot;Wrong file header.&quot;</span>;
                <span class="keywordflow">break</span>;
            <span class="keywordflow">case</span> 4: s += <span class="stringliteral">&quot;Empty data file.&quot;</span>;
                <span class="keywordflow">break</span>;
            <span class="keywordflow">default</span>: ASSERT(0);
            }
            AfxMessageBox(s);
            <span class="keywordflow">return</span>;
        }

        <span class="comment">// demonstrates how to handle TimeStamp dispatch</span>
        IDispatchPtr pStart = IMcdFile-&gt;GetStartTime();
        IDispatchPtr pStop = IMcdFile-&gt;GetStopTime();
        CComPtr&lt;MCStream::IMCSTimeStamp&gt; ItsStart;
        CComPtr&lt;MCStream::IMCSTimeStamp&gt; ItsStop;
        ItsStart = (MCStream::IMCSTimeStamp*) pStart.GetInterfacePtr();
        ItsStop = (MCStream::IMCSTimeStamp*) pStop.GetInterfacePtr();

        <span class="keywordtype">long</span> yearStart = ItsStart-&gt;GetYear();
        <span class="keywordtype">long</span> monthStart = ItsStart-&gt;GetMonth();
        <span class="keywordtype">long</span> dayStart = ItsStart-&gt;GetDay();
        <span class="keywordtype">long</span> hourSart = ItsStart-&gt;GetHour();
        <span class="keywordtype">long</span> minStart = ItsStart-&gt;GetMinute();
        <span class="keywordtype">long</span> secStart = ItsStart-&gt;GetSecond();

        TRACE(<span class="stringliteral">&quot;Start time of file: %d-%d-%d %d:%d:%d\n&quot;</span>, yearStart, monthStart, dayStart, hourSart, minStart, secStart);

        <span class="keywordtype">long</span> numStreams = IMcdFile-&gt;GetStreamCount();

        <span class="comment">// do something with the data streams</span>
        CString buffers;
        buffers.Format(<span class="stringliteral">&quot;%d buffers in file: &quot;</span>, numStreams);
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;numStreams; i++)
        {
            CComPtr&lt;MCStream::IMCSStream&gt; IStream = MakeSP&lt;MCStream::IMCSStream&gt;(IMcdFile-&gt;GetStream(i));

            buffers += IStream-&gt;GetBufferID().GetBSTR();
            buffers += <span class="stringliteral">&quot; &quot;</span>;
        }
        buffers += <span class="stringliteral">&quot;\n&quot;</span>;
        TRACE(buffers);

        <span class="keywordflow">if</span> (numStreams &gt; 0)
        {
            <span class="comment">// get some channel info for first buffer</span>
            CComPtr&lt;MCStream::IMCSStream&gt; IStream = MakeSP&lt;MCStream::IMCSStream&gt;(IMcdFile-&gt;GetStream(0));

            <span class="keywordtype">long</span> numChannels = IStream-&gt;GetChannelCount();
            CString channels;
            CString bufID = IStream-&gt;GetBufferID();
            channels.Format(<span class="stringliteral">&quot;%d channels in buffer %s: &quot;</span>, numChannels, bufID); 
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;numChannels; i++)
            {
                CComPtr&lt;MCStream::IMCSChannel&gt; IChannel = MakeSP&lt;MCStream::IMCSChannel&gt;(IStream-&gt;GetChannel(i));

                CString name = IChannel-&gt;GetDecoratedName();
                <span class="keywordtype">long</span> hwID = IChannel-&gt;GetHWID();
                CString tmp;
                tmp.Format(<span class="stringliteral">&quot;ch: %s, HWID: %d, &quot;</span>, name, hwID);
                channels += tmp;
                <span class="keywordflow">if</span> (i % 16 == 0)
                {
                    channels += <span class="stringliteral">&quot;\n&quot;</span>;
                    TRACE(channels);
                    channels = <span class="stringliteral">&quot;&quot;</span>;
                }
            }
            channels += <span class="stringliteral">&quot;\n&quot;</span>;
            TRACE(channels);
        }

        <span class="comment">// now do something different for each different type of buffer</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;numStreams; i++)
        {
            CComPtr&lt;MCStream::IMCSStream&gt; IStream = MakeSP&lt;MCStream::IMCSStream&gt;(IMcdFile-&gt;GetStream(i));
            CString bufferID = IStream-&gt;GetBufferID();
            <span class="keywordflow">if</span> (bufferID.Find(<span class="stringliteral">&quot;spks&quot;</span>) != -1)
            {
                <span class="comment">// see function ReadSpikeData()</span>
            }
            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bufferID.Find(<span class="stringliteral">&quot;elec&quot;</span>) != -1)
            {
                <span class="comment">// read first 100 ms of raw data</span>
                CComPtr&lt;MCStream::IMCSTimeStamp&gt; ItsStart = MakeSP&lt;MCStream::IMCSTimeStamp&gt;(IMcdFile-&gt;GetStartTime());

                ItsStart-&gt;SetNanosecondFromStart(0);
                ItsStart-&gt;SetMicrosecondFromStart(0);
                ItsStart-&gt;SetMillisecondFromStart(0);
                ItsStart-&gt;SetSecondFromStart(0);
                CComPtr&lt;MCStream::IMCSTimeStamp&gt; ItsEnd;

                <span class="comment">// must create a new object</span>
                IDispatchPtr pEnd;
                pEnd = ItsStart-&gt;Clone();
                ItsEnd = (MCStream::IMCSTimeStamp*)pEnd.GetInterfacePtr();
                ItsEnd-&gt;SetMillisecondFromStart(100);
                ItsEnd-&gt;SetMicrosecondFromStart(0);
                ItsEnd-&gt;SetNanosecondFromStart(0);
                ItsEnd-&gt;SetSecondFromStart(0);

                <span class="keywordtype">long</span> eventCount = 0;
                IStream-&gt;EventCountFromTo(ItsStart, ItsEnd, &amp;eventCount);
                TRACE(<span class="stringliteral">&quot;There are %d events in the first 100 ms\n&quot;</span>, eventCount);

                <span class="keywordtype">long</span> bufferSize = IStream-&gt;GetRawDataBufferSize(ItsStart, ItsEnd);
                <span class="keywordtype">short</span>* pBuffer = <span class="keyword">new</span> <span class="keywordtype">short</span>[bufferSize];

                <span class="keywordtype">long</span> rawDataCount = IStream-&gt;GetRawData(pBuffer, ItsStart, ItsEnd);
                <span class="keywordflow">if</span> (bufferSize != rawDataCount)
                {
                    TRACE(<span class="stringliteral">&quot;error reading data\n&quot;</span>);
                    <span class="keyword">delete</span>[] pBuffer;
                    <span class="keywordflow">return</span>;
                }

                TRACE(<span class="stringliteral">&quot;Data for first 100 ms\n&quot;</span>);
                <span class="keywordtype">long</span> numChannels = IStream-&gt;GetChannelCount();

                <span class="comment">// for raw data the following can be asserted</span>
                ASSERT(eventCount * numChannels == bufferSize);
                
                <span class="comment">// example for channel 0</span>
                <span class="keywordtype">int</span> offset = 0;
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;100; i++)
                {
                    <span class="keywordtype">short</span> d = pBuffer[(i*numChannels) + offset];
                    TRACE(<span class="stringliteral">&quot;%hd\n&quot;</span>, d);
                    <span class="comment">// the buffer contains the raw ADC data, these must be converted to real world units</span>
                    <span class="comment">// see function ReadContinuousRawData()</span>
                }
                <span class="keyword">delete</span>[] pBuffer;
            }
        }
        IMcdFile-&gt;CloseFile();
    }
}
</pre></div> </div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Oct 19 2010 16:59:49 for MCStream DLL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
